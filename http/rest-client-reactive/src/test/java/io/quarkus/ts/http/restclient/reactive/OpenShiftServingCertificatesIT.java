package io.quarkus.ts.http.restclient.reactive;

import static io.quarkus.test.openshift.utils.OpenShiftPropertiesUtils.buildAnnotationProp;
import static io.quarkus.test.openshift.utils.OpenShiftPropertiesUtils.buildMountSecretProp;
import static io.quarkus.test.openshift.utils.OpenShiftPropertiesUtils.createAnnotationPropertyKey;
import static io.quarkus.test.openshift.utils.OpenShiftPropertiesUtils.createSecretPropertyKey;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.Base64;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

import jakarta.inject.Inject;

import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import io.quarkus.test.bootstrap.Protocol;
import io.quarkus.test.bootstrap.RestService;
import io.quarkus.test.bootstrap.inject.OpenShiftClient;
import io.quarkus.test.logging.Log;
import io.quarkus.test.scenarios.OpenShiftScenario;
import io.quarkus.test.services.Certificate;
import io.quarkus.test.services.Certificate.ServingCertificates;
import io.quarkus.test.services.QuarkusApplication;
import io.quarkus.test.utils.AwaitilityUtils;
import io.restassured.http.ContentType;

import hero.CertificateInfo;
import hero.CertificateReloadDto;
import hero.Hero;
import hero.HeroClient;
import hero.HeroClientResource;
import hero.HeroResource;
import hero.InMemoryClientKeyStoreProvider;
import hero.TlsCertificateClient;
import hero.TlsCertificateClientResource;
import hero.TlsCertificateResource;
import hero.TlsCertificateUpdateResource;
import hero.Villain;
import hero.VillainClient;
import hero.VillainClientResource;
import hero.VillainResource;

/**
 * Test OpenShift serving certificate support and Quarkus REST client.
 */
@Tag("QUARKUS-4592")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@OpenShiftScenario
public class OpenShiftServingCertificatesIT {

    private static final String HERO_CLIENT = "hero-client";
    private static final String SERVER_TLS_CONFIG_NAME = "cert-serving-test-server";
    private static final int TIMEOUT = 50;
    /**
     * This secret contains 'tls.key' and 'tls.crt' key-value entries. Hence, the number 2.
     */
    private static final int SERVING_SECRET_DATA_SIZE = 2;

    @QuarkusApplication(ssl = true, certificates = @Certificate(tlsConfigName = SERVER_TLS_CONFIG_NAME, servingCertificates = {
            @ServingCertificates(addServiceCertificate = true)
    }), classes = { HeroResource.class, Hero.class, Villain.class, CertificateInfo.class, VillainResource.class,
            TlsCertificateResource.class }, properties = "certificate-serving-server.properties")
    static final RestService server = new RestService()
            .withProperty("quarkus.http.tls-configuration-name", SERVER_TLS_CONFIG_NAME)
            // the REST client use HTTPS but not mTLS
            .withProperty("quarkus.http.ssl.client-auth", "request")
            // client service certificates generated by OpenShift are not in injected server service CA bundle
            // I think that OpenShift doesn't support mTLS and the service certificates are intended to enable
            // HTTPS communication rather than mTLS, but I can be wrong; anyway, connection fails over unknown certificate
            // so following option enforces trust for the client certificates during client authentication,
            // because we need to inspect client certificates on the server side, so that we verify certificate rotation
            .withProperty("quarkus.tls.cert-serving-test-server.trust-all", "true");

    @QuarkusApplication(certificates = @Certificate(tlsConfigName = HERO_CLIENT, servingCertificates = {
            @ServingCertificates(injectCABundle = true)
    }), classes = {
            HeroClient.class, Hero.class, HeroClientResource.class, Villain.class, VillainClient.class,
            VillainClientResource.class, CertificateInfo.class, TlsCertificateClient.class, CertificateReloadDto.class,
            TlsCertificateClientResource.class, TlsCertificateUpdateResource.class,
            InMemoryClientKeyStoreProvider.class }, properties = "certificate-serving-client.properties")
    static final RestService client = new RestService()
            .withProperty("quarkus.rest-client.hero.uri", () -> server.getURI(Protocol.HTTPS).getRestAssuredStyleUri())
            .withProperties(() -> {
                // add the 'client' service certificates, FW only supports mounting service certificates for one service
                // TODO: we could improve FW to support as many service certificates as necessry
                var annotationVal = buildAnnotationProp("service.beta.openshift.io/serving-cert-secret-name",
                        "client-serving-certificates-secret");
                var annotationKey = createAnnotationPropertyKey();
                var mountSecretVal = buildMountSecretProp("client-serving-certificates-secret", "/etc/tls");
                var mountSecretKey = createSecretPropertyKey();
                return Map.of(annotationKey, annotationVal, mountSecretKey, mountSecretVal);
            });

    @Inject
    static OpenShiftClient openShiftClient;

    @Order(1)
    @Test
    public void testSecuredCommunicationBetweenClientAndServer() {
        // REST client use OpenShift internal CA
        // server is configured with OpenShift serving certificates
        // ad "untilAsserted": we experienced unknown SAN, so to avoid flakiness I am adding here retry:
        AwaitilityUtils.untilAsserted(() -> {
            var hero = client.given().get("hero-client-resource").then().statusCode(200).extract().as(Hero.class);
            assertNotNull(hero);
            assertNotNull(hero.name());
            assertTrue(hero.name().startsWith("Name-"));
            assertNotNull(hero.otherName());
            assertTrue(hero.otherName().startsWith("Other-"));
        }, AwaitilityUtils.AwaitilitySettings.usingTimeout(Duration.ofSeconds(TIMEOUT)));
    }

    @Order(2)
    @Test
    public void testConfiguredTlsProtocolEnforced() {
        // verifies that protocol version set in TLS config is obliged by both HTTP server and client
        // REST client requires TLSv1.2
        // HTTP server requires TLSv1.3
        client.logs().assertDoesNotContain("Received fatal alert: protocol_version");
        client.given().get("villain-client-resource").then().statusCode(500);
        client.logs().assertContains("Received fatal alert: protocol_version");
    }

    @Order(3)
    @Test
    public void testRestClientCertificateReloading() {
        // REST client use OpenShift internal CA and OpenShift serving certificates created for the 'client' service
        // server is configured with OpenShift serving certificates created for the 'server' service
        // we make a call, assert success
        // then we force certificate rotation in OpenShift
        // than we make another call, assert success and that a new (different) certificate has been used

        final AtomicReference<BigInteger> firstCertificateSerialNumber = new AtomicReference<>();
        AwaitilityUtils.untilAsserted(() -> {
            var certificateInfo = client.given().get("/tls-certificate/certificate-info").then().statusCode(200)
                    .extract().as(CertificateInfo.class);
            assertNotNull(certificateInfo);
            String expectedClientCertificatePrincipal = "CN=client.%s.svc".formatted(openShiftClient.project());
            assertEquals(expectedClientCertificatePrincipal, certificateInfo.principalName());
            firstCertificateSerialNumber.set(certificateInfo.serialNumber());
        }, AwaitilityUtils.AwaitilitySettings.usingTimeout(Duration.ofSeconds(TIMEOUT)));
        assertNotNull(firstCertificateSerialNumber.get());
        rotateClientCertificates();

        // now the operator needs to generate new secret and mount it, then Quarkus needs to detect the new certificate
        // but even if that happens, there is still active connection between the 'client' and 'server' that was opened
        // using the old certificates, so if we want to check the new certificates, hence kill the connection
        Log.info("Deleting '%s' service pod so that connection with '%s' service pod is disconnected", server.getName(),
                client.getName());
        openShiftClient.getFabric8Client().pods().withLabel("app.kubernetes.io/name", server.getName()).delete();
        openShiftClient.getFabric8Client().pods().withLabel("app.kubernetes.io/name", server.getName()).waitUntilReady(TIMEOUT,
                TimeUnit.SECONDS);

        AwaitilityUtils.untilAsserted(() -> {
            var certificateInfo = client.given().get("/tls-certificate/certificate-info").then().statusCode(200)
                    .extract().as(CertificateInfo.class);
            assertNotNull(certificateInfo);
            String expectedClientCertificatePrincipal = "CN=client.%s.svc".formatted(openShiftClient.project());
            assertEquals(expectedClientCertificatePrincipal, certificateInfo.principalName(),
                    "Client certificate info was: " + certificateInfo);
            assertNotEquals(firstCertificateSerialNumber.get(), certificateInfo.serialNumber());
        }, AwaitilityUtils.AwaitilitySettings.usingTimeout(Duration.ofSeconds(TIMEOUT)));
    }

    /**
     * When serving certificate secret changes, like when any other secret changes, you should delete pods to make sure
     * that rotated certificates are mounted to the new update. However, we want to test Quarkus TLS reload according
     * to the user scenario, so this method manually rotate served certificate and upload it to the in-memory keystore
     * provider. See <a href=
     * "https://docs.redhat.com/en/documentation/openshift_container_platform/4.18/html/security_and_compliance/configuring-certificates#add-service-serving">this
     * link</a> for more information about the rotation.
     */
    private static void rotateClientCertificates() {
        var fabric8Client = openShiftClient.getFabric8Client();
        var servingCertSecretResource = fabric8Client.secrets().withName("client-serving-certificates-secret");
        var servingCertSecret = servingCertSecretResource.require();
        var previousSecretUuid = servingCertSecret.getMetadata().getUid();
        servingCertSecretResource.delete();
        servingCertSecret = servingCertSecretResource.waitUntilCondition(
                svc -> svc != null && svc.getData() != null && svc.getData().size() == SERVING_SECRET_DATA_SIZE
                        && !previousSecretUuid.equals(svc.getMetadata().getUid()),
                TIMEOUT, TimeUnit.SECONDS);
        String tlsCrt = decodeCertificate(servingCertSecret.getData().get("tls.crt"));
        String tlsKey = decodeCertificate(servingCertSecret.getData().get("tls.key"));
        // upload current secret value to the in-memory keystore provider
        CertificateReloadDto requestDto = new CertificateReloadDto(tlsKey, tlsCrt);
        client.given().body(requestDto).contentType(ContentType.JSON).put("/tls-certificate/update").then().statusCode(204);
    }

    private static String decodeCertificate(String certificate) {
        return new String(Base64.getDecoder().decode(certificate), StandardCharsets.UTF_8);
    }
}
